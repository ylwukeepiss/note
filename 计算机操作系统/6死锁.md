## 死锁
#### 死锁的定义：如果一个进程集合中，每个进程都在等待只能由该进程集合中的其它进程才能引发的事件，那么，该进程集合就是死锁的；
#### 死锁发生的四个必要条件：
#### 1）互斥条件：每个资源要么已经分配给了一个进程，要么就是可用的；
#### 2）占有和等待条件：已经得到了某个资源的进程可以再请求新的资源；
#### 3）不可抢占条件：已经分配给一个进程的资源不能强制性地被抢占，它只能被抢占它的进程释放；
#### 4）环路等待条件：死锁发生时，一定有由两个或两个以上的进程组成的一条环路，该环路中的每个进程都在等待下一个进程所占有的资源； 

#### 死锁建模如下，圆形代表进程，方形代表资源：

![](../resource/操作系统/死锁示例图.png)

### 死锁检测算法：
#### 矩阵算法：定义E(existing resource vector)为现有资源向量，代表现有资源集合，A(available resource vector)为可用资源向量，代表可分配的资源结合，P代表进程集合，Pi代表第i个进程；
#### 此时还需要两个数组：C(current allocation matrix)代表当前分配矩阵，R(request matrix)代表待分配矩阵；
#### 其中Cij代表：进程Pi所持有的资源j的数量，Rij代表：进程Pi所需要资源j的数量；
#### 对于任意资源j存在于E中，且资源j要么处于已分配，要么处于可用状态；
#### 换而言之，如果将所有矩阵C中，已分配资源j的数量，加上集合A中，可分配资源的数量，结果就是资源集合E的总和；
![](../resource/操作系统/死锁检测矩阵算法.png)

```
    #define i 3                                         /*进程数量为3个*/
    #define j 4                                         /*资源种类为4种*/
    int[] E = {4,2,3,1};                                /*每种资源的数量*/
    int[] A = {2,1,0,0};                                /*每种资源剩余可分配数量*/
    int[][] C = new int[i][j];                          /*Cij代表 第i个进程，第j种资源已占有的数量*/
    int[][] R = new int[i][j];                          /*Rij代表 第i个进程，第j种资源欲请求的数量*/
    
    void request_allocation(int i, int j, int num) {    /*第i个进程，请求分配资源j，数量为num*/
        int total_j = num;                              /*资源j欲分配数量，已占用数量，可分配数量总和*/
        for (int a = 0; a < i; ++a) {
            total_j += C[a][j];
            total_j += R[a][j];
        }
        if (total_j > E[j]) {                           /*资源j总数量之和如果大于资源最大数量，则返回，不分配*/
            return;
        }
        if (num <= A[j]) {                              /*判断资源j的请求分配量 是否<=待分配数量？*/
            C[i][j] += num;                             /*执行分配*/
            A[j] -= num;                                /*资源j可分配数量减少*/
        } else {
            R[i][j] += num;                             /*数量大于可分配，则进入请求分配矩阵中*/
        }
    }
    
    void release_allocation(int i, int j, int num) {    /*第i个进程，释放资源j，数量为num*/
        // todo by wuyulun @date 2024-06-08 consider release timing
    }
    
    bool check_if_dead_lock_exist(void) {
        bool deadLock = false;
        while (TRUE) {
           // todo     
        }
        return dead_lock;
    }
```

### 死锁恢复
#### 假设死锁检测算法，检测到有死锁，则需要恢复手段，使得系统重新正常工作；
#### 1）抢占恢复：临时将某些资源从它的当前持有者转移给其它进程（缺点：但这取决于资源本身是否支持，且这种方法实现起来比较困难）；
#### 2）回滚恢复：周期性对进程的状态进行文件备份，一旦发现死锁，则选择一个资源冲突前的时间点，进行回滚，让出资源，挂起，等待其它进程使用该资源完毕，再重新运行（缺点：进程的运行会产生大量备份文件）；
#### 3）杀死进程恢复：杀死一个或多个进程，释放已然死锁进程所需的资源，使进程都能正常运行（缺点：所杀死的进程需格外小心，避免重新运行后，结果不一致）；

### 死锁避免——银行家算法，如上

### 死锁预防
#### 1）破坏互斥条件：资源不被一个进程所占有，例如假脱机打印机，进程通过与假脱机的守护进程交互，实现输入输出，而守护进程绝不会请求别的资源，因而打印机不会产生死锁；
![](../resource/操作系统/假脱机工作原理.png)

#### 2）破坏占有并等待条件：禁止已持有资源的进程，再请求其它资源（特定业务场景下，倒是可以考虑，进程需提前知道自己要用哪些资源）；
#### 3）破坏不可抢占条件：进程通过资源的守护进程进行交互，类似于虚拟化（缺点：如果是打印机之类的资源，可能会带来由磁盘空间产生的死锁，如果磁盘空间足够大，产生的概率则小一点）；
#### 4）破坏环路等待条件：将资源严格排序，进程访问资源时，严格按照一定的顺序访问（推荐，实际项目中很实用，例如商品库存扣减，按sku进行严格排序，就不会出现死锁问题）；
#### 死锁预防方法汇总：
<table>
    <th>条件</th>
    <th>处理方式</th>
    <tr>
        <td>互斥</td>
        <td>一切都使用假脱机技术</td>
    </tr>
    <tr>
        <td>占有和等待</td>
        <td>在开始就请求全部资源</td>
    </tr>
    <tr>
        <td>不可抢占</td>
        <td>抢占资源</td>
    </tr>
    <tr>
        <td>环路等待</td>
        <td>对资源按序编号</td>
    </tr>
</table>