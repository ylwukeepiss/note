#Redis之持久化
##RDB
### 说白了就是一个 数据库状态 保存为 rdb文件；rdb文件 还原 数据库状态的作用与过程，是一个经过压缩的二进制文件
### 提供手工备份和定时备份的方式
### SAVE：由服务端进程进行备份，同时服务端阻塞，客户端的请求命令都会被拒绝
### BGSAVE：由服务端进程派生出一个子进程进行备份
### SAVE 跟 BGSAVE无法同时或者在某一方未完成的情况下，就执行另一方，目的是避免rdbSave的并发调用产生竞争条件
### rdb文件备份还可以通过save配置，在xxx秒内进行了xxx次修改，即进行bgsave

###redis启动的时候，会先判断
###aof持久化功能是否开启？是->使用aof文件进行数据恢复，否->使用rdb文件进行恢复；rdb文件在载入时，服务端会处于阻塞状态

##AOF——append only file
###AOF持久化
###保存的是服务端的写命令，该功能分为三步，命令追加，文件写入，文件同步

###当aof持久化功能打开时，当服务端执行完一个写命令后，会追加到 struct redisServer中的 sds aof_buf，执行完后每次都要调用方法，确定是否要将aof_buf中的内容写入到aof文件

###持久化的策略是可设置的，always代表每次写入后都要将aof文件持久化，everysec代表写入后若上次持久化与这次超过了sec，则持久化，并且该操作由一个线程专门负责，no代表将aof_buf写入到aof文件中，但何时进行持久化，由操作系统决定
> 但是，aof文件，保存的是数据库的写命令，对于同一个键下的值，很可能要用多条命令

###AOF重写 （服务端执行 bgrewriteaof时候产生）
###解决aof持久化带来的文件过大的问题，aof重写只记录某一个键的最终状态，并不关心中间过程

###另开启一个子进程，利用重写缓冲区 + 读取数据库键，子进程读取数据库中的键并写入

###父进程在执行命令后会将命令写到aof重写缓冲区，当子进程完成工作后，会向父进程发送一个信号，父进程收到信号后会调用一个信号处理函数，处理如下：

###将aof重写缓冲区的内容写入到新的aof文件，这是aof文件与数据库状态一致
###对新的aof文件进行命名，原子地覆盖现有aof文件，完成新旧文件替换
###整个过程父进程处于阻塞状态，完成后才可继续处理客户端对请求

> 开启子进程的好处在于，子进程拥有父进程的数据副本，不像线程，数据同步时有锁的开销
> 
> 
> 