#进程间通信之操作系统与网络
##从操作系统的层面来看，进程间通信解决的问题有三个
###一个进程怎么把信息交给另一个进程：由于进程是共享同一地址空间，因此很好解决
###多进程竞争同一共享变量怎么保证安全性
###进程通信的顺序性，进程a产生信息，进程b打印信息

###竞争条件：多个进程访问同一变量，访问结果的正确性依赖于进程运行的精确时序

###临界区：多个进程访问的同一共享区域，称为临界区，避免多个进程同时进入临界区，就能避免竞争条件，实现方式为互斥锁。

###忙等待互斥
####1）屏蔽中断：进入临界区后，立即屏蔽所有中断，该cpu核就不会切换到其它进程，但把屏蔽中断的权力交到用户进程是不好的，万一用户进程处于阻塞，整个操作系统将无法继续工作，而在多核中，其它核心将会继续工作不受中断影响，因此本质上解决不了问题

####2）锁变量：通过锁变量的值来确定临界区域是否可以被访问，但同样该锁变量会有竞争条件

####3）严格轮换法：本质上是通过忙等待，确定是否能进入临界区，但缺点是浪费cpu时间，除非明确等待时间并不长，例如自旋锁

####4）Peterson解法：更小粒度的忙等待

####5）睡眠与唤醒：生产者询问队列空间是否为满，满则sleep，不满则添加，判断是否为刚添加，是就唤醒消费者；消费者发现队列为空，就sleep，否则消费，并判断刚刚队列是否为满，是则唤醒生产者；但是这样依赖一个cnt去记录队列状态，而对cnt的访问，也会产生竞争条件，最坏的结果是，队列满了，生产者消费者都在sleep

####6）信号量：解决生产者消费者访问共享变量的竞争条件问题，实现方式上是利用操作系统层的指令，暂时屏蔽全部中断，使得同一时刻只有一个cpu去访问该信号量，通过 down 和 up，保证临界区域只有一个进程访问

####7）互斥量：信号量的简易版，没有计数功能，同样能保证临界区只有一个进程访问，只有加锁和解锁的二元状态

##从网络看进程间通信
###远程进程间通讯，依赖于运输层建立的一条逻辑信道
###运输层有复用和分用的功能
###复用：应用层的进程通信，都要到运输层进行处理
###分用：网络层的信息，都要由运输层分发给上层应用层的具体进程
###分用的区分进程标准，依赖于端口号