#### 运输层：主要协议是TCP协议（UDP协议），向应用层提供通信服务，保证进程之间通信的可靠运输；
#### 运输层功能：分用和复用，可以同时为主机上的不同进程提供准确通信；

<table>
    <th>模型层级</th>
    <th>通信端点</th>
    <th>主要功能</th>
    <th>通信类型</th>
    <th>连接方式</th>
    <tr>
        <td>网络层</td>
        <td>主机</td>
        <td>数据交付</td>
        <td>逻辑通信</td>
        <td>无连接</td>
    </tr>
    <tr>
        <td>运输层</td>
        <td>主机中的进程</td>
        <td>复用和分用功能</td>
        <td>逻辑通信</td>
        <td>有连接</td>
    </tr>
</table>

![](../resource/image/计算机组成原理/运输层通信流程.png "1")

#### TCP协议主要特点：
#### 1）面向连接：使用TCP协议之前，必须先建立连接，结束后，释放连接；
#### 2）每个连接有2个端点：每连接每服务，一对一通讯；
###### TCP连接的端点：socket -> (IP地址：端口号)
###### TCP连接：{socket1, socket2} == {(IP地址1:port1),(IP地址2:port2)}
#### 3）提供可靠交付：通过TCP连接的数据，无差错、不丢失、不重复、按序到达；
#### 4）提供全双工通信：允许应用程序进程双方同时发送数据；TCP连接的两端都设有发送缓存和接收缓存；
###### 发送时，应用程序在把数据传送给TCP缓存后，就可以做自己的事了，而TCP在合适的时候把数据发送出去。
###### 接收时，TCP把收到的数据放入缓存，上层的应用在合适的时候读取缓存中的数据；
#### 5）面向字节流：指流入到进程或从进程流出的字节序列；
###### TCP并不关心从应用层传递下来的字节序列长度，也不关心具体内容，而是将缓存中的数据，根据接收方的窗口值和拥塞程度，来决定一个报文段应包含多少字节，从而发送出去；
###### 如果数据块太长，TCP可以分为几个小的；反之，如果太小，可以等待积累足够多的字节，再发送出去；

![](../resource/image/计算机组成原理/TCP面向字节流概念.png "1")

## 可靠性传输的基本原理：
#### 停止等待协议：每请求每响应，出错的情况下自动重传，缺点是信道利用率低；
#### 连续ARQ协议：滑动窗口协议，指的是窗口内的分组可以连续发送出去，而不用等待接收方确认，提高了新到利用率；接收方只需对按序到达的最后一个分组进行确认；
###### 连续ARQ优点：容易实现，即使确认丢失也不必重传；
###### 连续ARQ缺点：发送分组如果出现丢失，接收方无法通知发送方，发送方只能通过超时重传；

# TCP可靠性传输的实现：
## 以字节为单位的滑动窗口
#### 发送的窗口
![](../resource/image/计算机组成原理/TCP滑动窗口.png "1")

#### TCP发送缓冲区、接收缓冲区
#### 发送缓存暂时存放：
#### 1）发送应用程序传送给对方TCP准备的数据；
#### 2）TCP已发送但未收到确认的数据；
###### 已被确认的分组，将从发送端的缓存中剔除，发送端应用程序需要控制写入缓存的速率，否则发送缓存就没有存数据的空间；

#### 接收缓存暂时存放：
#### 1）按序到达的、但尚未被接收应用程序读取的数据；
#### 2）未按序到达的数据；
###### 如果接收端应用程序来不及读取收到的数据，接收缓存最终会被填满，接收窗口减小到0。
###### 反之，如果接收端应用程序能及时地从缓存中读取收到的数据，接收窗口就可以增大，但大小不能超过缓存的最大值。

![](../resource/image/计算机组成原理/TCP缓存跟窗口的关系.png "1")



## 超时重传时间选择
#### 自适应算法

<table>
    <tr>
        <td>名词</td>
        <td>RTT</td>
        <td>S</td>
        <td>RTTs</td>
        <td>α</td>
        <td>RTTO</td>
        <td>RTTD</td>
        <td>β</td>
    </tr>
    <tr>
        <td>解释</td>
        <td width="800px">报文段平均往返时间</td>
        <td>Smooth 平滑</td>
        <td width="800px">加权平均往返时间</td>
        <td width="100px">加权平均值 RFC6298标准为0.125</td>
        <td>Retransmission Time-Out 超时重传时间</td>
        <td>RTT的偏差的加权平均值</td>
        <td>0.25 计算RTTD时需要用到</td>
    </tr>
</table>

#### 自适应算法的目的是针对复杂网络环境下，实时计算出报文重传的最佳时间，这里过于复杂，后续再深入去了解；


#### 选择确认SACK
#### 接收端用两个指针维护接收到的报文端，并响应给发送端，发送端根据指针维护到的报文段，查询出缺失的，并决定是否重传；

## TCP流量控制

#### 利用滑动窗口，限制发送方发送的字节不能超过接收方窗口（此时接收方窗口指的是TCP接收缓存剩余空间大小）；
###### 当接收方的窗口为0时，发送方不应再发送，等接收方消化完腾出空间后，再通知发送方当前接收窗口大小，发送方再发送；
###### 此处，为避免接收方所发送的窗口大小响应包丢失，造成发送方无限等待的死锁问题，发送方可以在接收到0窗口时，启动定时器，定时器结束后，若还没有收到响应包，可以向接收方发送一个0窗口探测包；

#### TCP传输效率：发送方尽量不要发送太小的报文，接收方也不要在接收窗口刚腾出一点空间时，就立即通知发送方；

## TCP拥塞控制
#### 拥塞的原因：∑ 对资源对需求 > 可用资源；
#### 拥塞控制的原则：防止过多的数据注入到网络中；
#### 拥塞控制的方法：开环控制和闭环控制；
###### 开环控制：设计网络时事先将有关发生拥塞的原因考虑到，力求网络在工作时不产生拥塞，但一旦系统运行起来，中途就不再更改。
###### 闭环控制：基于反馈，检测网络系统在何时何地发生拥塞，将信息传送给相应可控方，基于此调整出现问题的地方。
#### 拥塞控制算法：
#### 

<table>
    <th>TCP可靠机制</th>
    <th>控制端</th>
    <th>作用端</th>
    <tr>
        <td>流量控制</td>
        <td>接收端</td>
        <td>发送端</td>
    </tr>
    <tr>
        <td>拥塞控制</td>
        <td>发送端</td>
        <td>发送端拥塞窗口</td>
    </tr>
</table>
