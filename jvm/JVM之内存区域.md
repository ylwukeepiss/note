#JVM之内存区域
##JVM在执行Java程序的过程中会把它所管理的内存划分为5个区域，有些依赖虚拟机进程的启动而存在，有些则依赖用户线程的启动和结束而建立与销毁块，每一个模块有独特的功能。
###程序计数器
####jvm是多线程机制，但在某一个时刻下，只会去执行某一个线程的某一个指令，因此需要一个程序计数器，记录某一个线程执行到哪一条指令（具体内容为虚拟机字节码指令的地址），这是属于线程私有的内存。
###Java虚拟机栈
#### 也是属于线程私有的，生命周期与线程相同，记录线程内一个方法执行过程中 局部变量表，操作数栈，动态连接，对象引用、8大基本数据类型、方法出口等信息。
###本地方法栈
####同样是线程私有，与java虚拟机栈的区别在于，本地方法栈是为虚拟机使用到的本地方法服务。
###Java堆
####被java所有线程共享的一块内存区域，在虚拟机启动时创建，存放对象实例。但所有线程共享的java堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer），以提升对象分配时的效率，这也是垃圾收集器管理的内存区域，也称为GC堆，从内存回收的角度看，现代垃圾收集器大部分都是基于分代收集理论设计的，大小可以通过-Xmx 和 -Xms设定。
###方法区
####Java各个线程共享的内存区域，用于存储已被虚拟机加载的类型信息，常量，静态变量等代码缓存数据，当new一个对象时，会先检查该类是否已在方法去中加载过，如果没有，则现在方法去中加载该类，后再去堆中分配该对象实例所需内存空间。
##直接内存
###并非虚拟机运行时数据区的一部分。避免数据从Java堆到内存堆到来回拷贝。在Java中，有NIO调用时需特别小心，容易在DMA中抛出OOM Error，但无法通过HeapDumpOOMError参数配置显示。可通过-XX：MaxDirectMemorySize调整大小，由于并非在JVM运行时数据区的管辖中，因此该区域大小不受Java堆分配影响，但同样会受物理机内存大小以及处理器寻址能力的影响。
##当虚拟机遇到一条new指令时，是如何创建对象？
###首先jvm会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用。并检查该符号引用所代表的类是否已被加载、解析、和初始化过，如果没有，执行相应过程。在类经过加载检查后，jvm为新生对象分配内存。将一块确定大小的内存块从java堆中划分出来。jvm为新对象划内存的方式有两种，”指针碰撞“ 和 ”空闲列表“，当内存比较规整，则采用指针碰撞方式，向空闲内存挪动一段与对象大小相等的距离，否则则采用jvm自行维护的空闲列表，获取足够大的内存地址来存储对象，内存是否规整，由所采用的垃圾收集器算法是否带有空间压缩整能力所决定，像Serial、ParNew等带有空间压缩能力等，系统采用的分配算法就是“指针碰撞”，而当使用CMS这种基于清除算法的收集器时，理论上就只能采用较为复杂的空闲列表来分配内存。

##内存溢出与内存泄漏
###内存溢出：指的是新对象的创建并没有足够的空间来容纳，直接抛OOM异常。
###内存泄漏：指一个大对象在内存中生命周期过长，并不会立即引发问题，但随着应用程序的运行，新对象的不断创建，该大对象又无法回收，则很可能因Java堆空间不足而引发内存溢出。