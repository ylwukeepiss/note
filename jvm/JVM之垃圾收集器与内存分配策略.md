#JVM之内存分配策略
##内存自动回收，面临的问题是，哪些内存需要回收？什么时候回收？怎么回收？
###引用计数算法：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为0的对象不可能再被使用；但是这个算法无法解决循环引用的问题。

###可达性算法：从GC Roots到这个对象不可达时，证明该对象不可能再被使用，在Java技术体系里，固定可作为gc roots对象包括，虚拟机栈中引用的对象、方法区中类静态属性引用的对象，方法区中常量引用的对象，本地方法栈引用的对象、虚拟机内部的引用如基本数据类型对应的Class对象，一些常驻的异常对象，如NPE，OOMError，系统类加载器，所有被同步锁持有的对象，反映JVM内部情况的JMXBean、JVMTI中注册的回调，本地代码缓存等。

#JVM之垃圾收集器
##垃圾回收算法基于Java内存划分后的分代理论假说，并在实际业务场景中对分代理论演进而改进，最后在各个JDK版本中迭代出来，体现在不同的垃圾收集器上。

###分代理论假说基于三种：
###1) 弱分代假说，绝大多数对象都是朝生夕灭的。

###2）强分代假说，熬过越多次垃圾收集过程的对象就越难消亡。
###这两个假说，奠定了垃圾收集器将Java堆划分出不同区域，然后依据回收对象年龄分配到不同的区域中，有了区域划分，垃圾收集器才能每次只针对特定的区域进行回收，兼顾了效率和空间利用。

###才有了Partial GC （Young GC 新生代， Old GC 老年代， Mixed GC【目前只有G1收集器才有】）， Full GC（作用于整个Java堆）的回收类型区分。

###才有了与对象存亡特征相匹配的垃圾收集方式， 标记-清除、标记-复制、标记-整理算法。

####标记-清除：将所需要回收的对象进行标记，然后回收，这个算法有两个问题，第一，整个过程，时间和内存耗费随着对象的数量增加而增加，第二，会产生大量的内存碎片空间，导致新对象分配内存时，会由于找不到连续的空间而重新出发垃圾回收。

####标记-复制：为了解决回收后空间碎片问题，该算法将内存划分为相同的两块，每次只使用其中一块，内存用完时，就将存活的对象复制到另一块内存上，然后再把已使用的内存空间一次清理掉。这样做的问题是，当存活对象过多时，会产生大量的对象复制开销。

####这里，根据新生代“朝生夕灭”的诠释——新生代98%的对象熬不过第一轮收集，给新生代划分内存区域时，并不需要按照1:1，而是划分为3块，按8 ：1 ：1进行划分，一个Eden区，两个Survivor区，每次分配内存只分配一个Eden跟一个Survivor区域，回收时基于标记-复制算法，将新生代中熬过第一轮收集的对象，复制最后一个Survivor区域中，然后一次性清理Eden跟Survivor区，当对象无法放入Survivor时，直接晋入老年代（以其他区域进行分配担保，在发起Minor GC前，JVM会先检查老年代最大可用连续空间是否大于历次新生代所有对象总空间，如果大于，则此次Minor GC是安全的，如果不大于，则先查看是否有空间分配担保，如果有，继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，是，则尝试进行一次Minor GC，否，则进行Full GC。在JDK6 Update24之后，规则就改为，只要老年代的连续空间大于新生代对象总大小或者历次晋升平均大小，就会进行Minor GC，否则将进行Full GC）。

####对象晋入老年代三个条件：
#####1.年龄达到MaxTenuringThreshold参数值
#####2.对象无法放入新生代区域。（大对象直接晋入老年代）
#####3.同年对象达到Survivor空间一半，Young GC时，该对象会晋入老年代。
####标记-整理：老年代回收算法，基于老年代对象的存亡特征，该算法让所有存活对象都向内存空间的一端移动，然后直接清理掉边界以外的内存，相比新生代算法 —— 标记-清除 非移动式算法，这是一种移动式算法。该移动式算法的风险在于，如果移动存活对象，尤其是老年代这种每次回收后均有大量对象存活区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且必须Stop The World，
####垃圾回收时，移动存活对象则造成系统停顿，不移动则造成空间碎片问题（对于这类型问题只能依赖 “分区空闲分配链表”来解决内存分配问题）。综上两点，JVM需要考虑的是系统吞吐量，即用户线程与垃圾收集线程的效率总和，移动对象虽然增加了系统停顿时间，但因高频率的内存访问和分配在移动式对象回收方式下取得效率提升，总的系统吞吐量还是因此上升了。
####还有一种“和稀泥式”做法，在回收时大部分时间采取非移动式算法，暂时允许空间碎片问题存在，等到一定程度之后，再采用一次移动式回收，以获得规整的内存空间。基于标记-清除算法的CMS收集器，在内存空间碎片问题严重时，就是采用这种策略。
###3）跨代引用假说：跨代引用相对于同代引用来说仅占极少数。存在引用关系的两个对象理论上倾向于同时存亡，如果新生代对象存在跨代引用，收集几次之后晋入老年代，则这是跨代引用消除，因此不应再为少量跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的“记忆集”，将老年代划分为若干个小块，此后当发生Young GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。虽然这种方法需要在对象改变引用关系时维护记录数据的正确性，增加运行时开销，但相较于扫描整个老年代来说仍然划算。

##经典的垃圾收集器目前由7种，作用于新生代和老年代，除了G1收集器可同时作用于两个年代的对象，其余的都需要搭配使用。
##Serial收集器
###单线程收集器，工作时需要停止用户线程，俗称“Stop The World”，由虚拟机在后台自动发起和自动完成，在用户不可知不可控的情况下把用户的正常工作的线程全部停掉，这通常来说是很差的体验，但它的优点同样很明显，就是简单高效，没有了线程切换开销，并且内存消耗低。（作用于新生代）
##ParNew收集器
###Serial收集器的多线程升级版（作用于新生代，但已退出历史舞台）。
##Parallel Scavenge收集器
###基于 标记-复制 算法实现的并行多线程收集器。目标是达到一个可控制的吞吐量（吞吐量 = 运行用户代码时间 / （运行用户代码时间 + 运行垃圾收集时间））。
##Serial Old 收集器
###Serial收集器的老年代版本，单线程收集器，使用 标记-整理算法。
##Parallel Old收集器
###Parallel 收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现，JDK6开始才提供。
##CMS收集器
###全称为 Concurrent Mark Sweep收集器，基于 标记-清除算法实现，目标是获取最短回收停顿时间，常用于Java应用中互联网网站、基于B/S浏览器的系统服务端上，较为关注服务的响应速度，希望系统停顿的时间尽可能地短，以给用户带来良好的体验。并发低停顿收集器。increamental CMS（增量式并发收集器），在并发标记、清理的时候让用户线程和收集器线程交替运行，尽量减少垃圾收集线程的抢占资源的时间，然而实践结果是ICMS效果很一般，从JDK7开始已经不提倡用了，到了JDK9，官方宣布G1收集器彻底取代CMS收集器。
##Garbage First 收集器
###JDK7时移除了G1收集器的实验室标识，JDK8时G1提供并发的类卸载的支持。对于G1收集器来说，新生代与老生代的概念虽然保留，但已经不再是固定的，都是一系列区域的动态集合。G1收集器之所以能建立可预测的停顿时间模型（指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒），是因为它将Region作为单次回收的最小单位，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。具体实现是让G1收集器去跟踪各Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间，优先处理回收价值收益最大的那些Region。这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率。
##总结
###垃圾收集器都是朝着一个“不可能三角”的目标尽量靠近，即 内存占用，吞吐量和延迟，一款优秀的收集器通常最多可以同时达成其中两项，在硬件水平提高的今天，允许收集器在内存占用不做过多要求，从Serial到CMS，再到G1，再到Shenandoah、ZGC，从全程单线程到全程可并发，经历了整整二十年，几代垃圾收集器，在分代收集理论假说上，对 标记-清除、 标记-复制、 标记-整理算法进行耦合，到了JDK8时，内存空间已经不再像之前那么稀缺，G1收集器将Java堆切分为一个个Region进行管理，支持停顿时间可配置，G1收集器根据停顿时间参数，自动计算并筛选出内存回收收益最大的Region，而不是全部回收... 但缺点是该算法的内存占用比之前的垃圾收集器都要大，Shenandoah 跟 ZGC 在沿用G1内存划分与管理的方式上做进一步优化，做到了短暂的停顿只与GC Roots大小相关而非与堆内存空间大小相关。
