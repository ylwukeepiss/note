#Java内存模型之JMM
###背景：cpu的运行速度与主内存之间存在差异，于是cpu内置了工作内存（L1，L2，L3），来缓解这种速度差异，但带来的问题是变量缓存一致性的问题，加入了缓存一致性协议后，又带来了内存可见性问题，而编译器和cpu的指令重排功能，又带来了原子性和有序性问题，尽管有处理这些问题的原子操作指令，但不同的系统，原子语义是不同的，开发人员的代码不可能去兼容所有的平台，而JMM的出现，就是给多线程操作提供一系列的规范约束。

###原子性：JMM通过 read write load assign use store 来保证原子性操作，此外还有synchronized 跟 reentrantLock

###可见性：JMM通过volatile final 去修饰变量，保证该变量的修改对于其它线程是可见的

###有序性：volatile synchronized reentrantlock 加内存屏障保证指令不重排

##主内存与工作内存之间的交互协议
###即一个变量，如何从主内存拷贝到工作内存、如何从工作内存写回主内存这一类的细节实现，JMM提供了8种操作来完成，JVM实现时，必须保证每一种操作都是原子的，不可再分的。
###lock：作用于主内存的变量，它把一个变量标识为一条线程独占的状态
###unlock：作用于主内存中的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其它线程锁定
###read：作用于主内存中的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用
###load：作用于工作内存中的变量，它把read操作从主内存中获取到的变量，存入到线程工作内存的变量副本中
###use：作用于工作内存中的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作
###assign：作用于工作内存中的变量，