# MySQL之锁
## MySQL为什么要有锁？
### mysql是一个面向多用户的数据库驱动应用，一方面要最大程度地承受并发访问，一方面要保证每个访问能以一致的方式读取和修改数据，因此有了锁的机制，用于管理对共享资源的并发访问。
### innodb中锁的类型有2种：共享锁 和 排他锁。由此衍生的锁的算法有3种
### record lock:单个行记录上的锁。
### gap lock:范围锁，锁定一个范围但不包含记录本身。
### next-key lock: record lock + gap lock，不仅锁住一个范围，也包含范围的记录本身。
### innodb中事务隔离性中的repeatable read 便是由next-key lock 算法实现，从而避免幻读造成的行数前后不一致问题 和 不可重复读中的行内容前后不一致问题。
### innodb存储引擎下的事务遵循acid规范，其中的isolation 隔离性，具备4种级别：read-uncommitted(读未提交) read-committed(读已提交）repeatable read（可重复读）serializable（序列化）,资源耗费从左到右依次增加；
### |---隔离级别-----------------|--脏读--|--不可重复读--|--幻读--|--加锁读
### |---read-uncommitted---|-yes----|-yes-------------|--yes--|--no---
### |---read-committed-------|-no-----|-yes-------------|--yes--|--no--
### |---repeatable-read-------|-no-----|-no---------------|--yes--|--no
### |---serializable-------------|-no-----|-no---------------|--no---|-- yes
### 开2个会话，打开2个事务，模拟并发情况下
### 脏读：在事务b中插入一行数据但未提交，在事务a中能读取到改行数据。
### 不可重复读：在事务b中修改一行数据并提交，在事务a中能读取到修改后的行数据，重点在于修改。某种程度上来说，这是被允许的。（在innodb中，通过使用Next-Key Lock 算法来避免不可重复读读问题。比如对于select * from t where a <= 5, 在隔离级别为repeatable-read 下，不仅锁住了扫描到的索引，还锁住了这些索引覆盖的范围。）
### 幻读：在事务b中在事务b中插入or删除一行数据并提交，在事务a中前后读取的行数据量不同，重点在于 插入 or 修改。某种程度上来说，这是被允许的。
### 加锁读：通过加锁读方式强制事务串行化之行。
## 事务操作数据的过程中，为了保证数据安全，会用锁来锁住数据，事务在执行过程中，因争夺锁资源而造成互相等待的现象，称之为死锁。
### innodb中，解决死锁的方式有2种：
### 一种是超时回滚，即2个事务相互等待时，当一个的等待时间超过阈值，将其回滚，另一个继续进行，通过innodb_lock_wait_timeout参数来设置等待阈值。这个方法的弊端在于，如果回滚的事务所占执行权重比较大，例如事务操作更新了很多行，占用了较多的undo log，回滚这个事务的时间相对另一个事务所占用的时间可能会很多。
### 另一种是普遍采用的wait-for graph方式来进行死锁检测，事务执行时，innodb保存锁的信息链表 和 事务等待链表 两种信息，通过信息构成一张等待图，每一个事务请求锁并发生等待时都会判断是否存在回路，当出现回路的情况下，即为死锁，Innodb选择回滚undo量最小的事务。
## 死锁的预防
### 这里说结论，系统中事务数量多是没办法的事情，但应用程序中，应控制每一个事务中，尽可能少地操作数据库表中的数据，简单地说，使得数据库中锁占用的时间少，数量少，锁住的范围小。

##mysql的锁也会带来三个问题
###脏读：读到其他事务未提交的数据，这种情况通常发生在隔离级别为read-uncomitted

###可重复读：读到其他事务提交的数据，这种情况通常发生在隔离级别为read-committed中，但这种情况是能接受的，如果使用了next-key lock，还是能保证不让某些范围内的数据出现重复读的情况

###丢失更新： 指的是，一个事务中的更新，被另一个事务中的更新所覆盖，举个例子，开启两个客户端，对账号为1w元的账户进行转账，a转账9000，b转账1元，原本账户应该剩下999元，但由于b中的事务覆盖了a中的事务更新，最终账户有9999元，钱变多而账不平。。这种情况下只能将事务变成串行，在a中转账更新前，先通过select * from account where num = 'xxx' for update，挂上一个排它锁，此时b客户端的转账1元操作将被阻塞，a客户端通过select发现余额足够，进行update操作，然后释放锁，b客户端执行同样流程
