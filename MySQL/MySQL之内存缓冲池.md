# MySQL之内存
## MySQL为什么要在内存开辟出一个缓冲池(innodb_buffer_pool)？
### mysql是基于磁盘进行文件存储的数据库系统，这就面临一个问题，cpu跟磁盘之间的速度鸿沟，内存缓冲池在内存开辟出一块区域，用于弥补该问题。
## MySQL内存中的缓冲池做了什么事情？
### 先说结论，比如读取一行记录，mysql需要检索到该记录所在的页，并将该页load到内存中，下次读取行记录请求时，检索该行所在的物理地址和内存中的页是否吻合，如果存在，直接命中并返回，提高了访问速度，减少了磁盘IO，数据页只是占缓冲池很大的一个部分，锁信息，insert buffer，自适应哈希索引都在缓冲池中。
### 其次是，对于行记录的修改，并不会立即保存到磁盘中，而是先修改缓冲池中的页，然后以页为单位，按一定的频率刷新到磁盘中，这个频率通过 checkpoint机制进行控制，这种机制的存在，也是为了弥补cpu跟磁盘之间速度鸿沟的问题，以及后续一些事务实现相关的考虑。
### 最后，mysql允许缓冲池实例有多个，这是为了减少数据库内部的资源竞争，增加数据库的并发处理能力，每个页根据哈希值平均分配到不同的缓冲池实例中。
### innodb对缓冲池的管理是通过LRU算法，即最频繁页在前端，当不能存放新的页时，LRU算法会将尾端的页释放掉，腾出空间。但是这里会有一个问题，用户经常在进行某些sql时操作时会带出大量的页，例如进行了索引或数据扫描，但这些页又仅仅只是本次查询所需要的，LRU会将真正的热点数据替换出去，导致每一次查询热点数据，都有可能因为一次偶然的大批量操作而需要重新从磁盘中读取，势必降低性能......innodb基于这类型的业务场景业务场景对传统的LRU算法进行了改造，引入了midpoint机制，即即可midpoint之前的称为hot数据列表，midpoint之后的称为old数据列表。并且引入innodb_old_blocks_time参数机制，用于表示页读取到mid位置后，需要等待多久才能进去hot端，可以通过增大该参数值，尽可能地保证热点数据不被刷出去。midpoint参数设置得越小，表示新读取的页越靠近尾端。
### 缓冲池中除了LRU list 之外还有Flush List 跟 Free List，数据库刚启动的时候，LRU中是没有页的，这是页都放在Free 中，当需要从缓冲池中分页时，首先从Free列表中查找是否有可用的空闲页，若有责将该页从Free列表中删除，放到LRU列表中，至于Flush list，是当LRU中的页被修改后，成为脏页，即缓冲池中的页与磁盘中的页的数据产生了不一致，这是会通过checkpoint机制，将脏页刷新到Flush列表中，即脏页列表。
### 上述提到的checkpoint机制，应对一种问题，即脏页始终是要刷新到磁盘中的，但倘若每一次脏页产生就去刷新磁盘，开销是非常巨大的，同时，如果刷新的过程中发生了宕机，数据就不能恢复，为了避免数据丢失，采用了write-ahead-log策略，即当事务提交时，先写日志，后修改页，这样子当数据库发生宕机时，可以通过redo log进行数据恢复（这也是acid中 持久性的要求），但是，当redo log很大时，如果通过所有文件恢复，会耗费数小时甚至数天的时间，在事务提交过程中缓冲池不够用时怎么处理？checkpoint解决的问题时，缩短数据库的恢复时间；当缓冲池不够用时，将脏页刷新到磁盘，redo log 不可用时，刷新脏页；着重点在于，每次刷新多少页到磁盘，从那里取脏页，什么时间出发checkpoint机制
