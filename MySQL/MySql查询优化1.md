# MySql
## 查询优化
### 先说结果，碰到 select * 一定 一定 一定 要慎重对待，是否真的需要取出所有的字段?
### 举个例子，在跨表查询中：
### select * from t_teacher t left join t_student s on t.class_id = s.class_id;
### 上述sql语句会将所有满足条件的 t 和 s 的字段取出，这里如果只需要取出t，可以优化为:
### select t.* from t_teacher t left join t_student s on t.class_id = s.class_id;
### 取出全部的列，会让优化器无法完成索引覆盖扫描这类优化，还会为服务器带来额外的I/0 、内存、cpu消耗。
## 衡量慢查询开销的三个简单指标
### 响应时间、扫描的行数、返回的行数
### 响应时间：由服务时间 和 排队时间组成；服务时间是指数据库处理这个查询真正花了多少时间。排队时间是指服务器因为等待某些资源而没有真正执行查询的时间，可能是在等待I/O时间，也有可能是在等待行锁，真实情况更加复杂。
### 扫描行数 和 返回的行数：较短的行访问速度更快，内存中的行也比磁盘中的行访问速度要快得多; 扫描的行中，访问的类型分为很多种，从全表扫描到索引扫描，范围扫描，唯一索引扫描，常数引用，扫描速度从慢到快，扫描行数也是从小到大。
###索引是以最少的扫描行数找到需要的记录的办法。
## 具体优化方式
### 理解一个查询需要扫描多少行 和 实际需要用到的行数，需要先去理解这个查询背后的逻辑和思想。如果发现查询需要扫描大量的数据但只返回少数的行，通常可以从以下几个角度去优化它:
### 使用索引覆盖扫描，把所有需要用的列都放到索引中，这样存储引擎无需回表获取对应行就可以返回结果；
### 重写复杂的查询，让MySQL优化器能够以更优的方式执行这个查询。
### 利用MySQL的缓存，将关联查询分解为单查询
### select * from tag
### join tag_post on tag_post.tag_id = tag.id
### join post on tag_post.post_id = post_id
###  where tag.tag = 'mysql';

### select * from tag where tag = 'mysql';
### select * from tag_post where tag_id = 1234;
### select * from post where post_id in (123, 456, 789);

### 应用程序可以方便地缓存单表查询结果对象，查询分解后，执行单个查询可以减少锁的竞争，在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展。