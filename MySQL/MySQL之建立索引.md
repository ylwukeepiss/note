# MySQL之索引相关以及数据存储
## mysql的索引有什么用？
### mysql表中的行记录数据，本身是以页为单位，存储在一颗B+树中的，通过索引检索，从B+树中找到相关行记录所在的页（也可以称之为数据块），简单地说，通过建立索引，可以更快地获取到数据。
## mysql通常可以建立哪些索引，又各自有什么应用场景，何时建立？
### mysql有主键索引，辅助索引，联合索引...
### 主键索引：innodb存储引擎表是索引组织表，即表中数据按照主键顺序存放，按照每张表的主键（若表中存在多个not null & unique 列，则选取第一个创建的满足条件的列作为主键，如果没有，InnoDB存储引擎会自动创建一个6字节大小的指针，作为主键）构造一颗B+树，同时叶子结点存放的是整张表的行记录数据，叶子结点称为数据页，每一个数据页都通过一个双向链表来进行链接。实际上数据页只能按照一颗B+树进行排序，因此每张表只能拥有一个主键索引，查询优化器倾向于采用主键索引，毕竟主键索引能在B+树索引的叶子结点上直接找到数据，按照B+树根节点存放主键索引方式可以看出，由于数据采用了逻辑顺序存储，因而主键索引针对范围查询和排序查询时非常快。
### 辅助索引：也是一颗B+树，叶子结点存放的是一个书签——主键索引，innodb再通过主键索引扫描主键索引树，获取行记录所在的页到内存中，从而获取相应行。但是，通过扫描辅助索引获取书签后，再进行主键索引扫描回表查数据的前提是，获取的数据量很少，否则当数据量很大时，还是只会进行主键索引扫描，而不走辅助索引查询，举个例子，订单表中，orderId为辅助索引，select * from t_order t where t.orderId between 10000 and 102000; 首先，辅助索引并不能满足所有的行信息获取，其次，即使走了辅助索引，获取到主键，再次进行主键索引查询时，是离散读，并非顺序读，因此sql优化器最终只会选择主键查询。如果mysql启用了MRR(multi-range-read)优化技术，情况或许会好一些，mmr会将辅助索引获取的书签进行排序再进行全表扫描，将离散读变得较为顺序，也能减少缓冲池中页被替换的次数。
### 联合索引：本质上也是一颗B+树，联合索引的键值数量大于1，联合索引的好处是对第二个键值进行了排序，举个例子，用户购买记录表，有 userId 跟 creationTime 这两个字断，获取某个用户最近3次购买记录: select * from t_buy_log t where t.userId = params order by t.creationTime desc limit 3，在这里如果仅仅只走userId索引，则还需要对满足条件的* 做一次 file sort，如果建立联合索引（userId, creationTime)，则走联合索引树，此时(userId, creationTime) 中，creationTime 是 排序好的，因此可以避免一次排序操作。
### 覆盖索引：sql优化器选择的执行路线，能从联合索引B+树中获取想要的数据，就不再需要进行全表扫描。
## mysql如何保存数据？
### 从InnoDB存储引擎的逻辑存储结构看，所有数据都被逻辑地存放在一个空间中，称之为表空间，表空间 -> 段 -> 区 -> 页（有些也称之为块）；行记录存放在页中，首先，建表时，选取表中第一个满足条件的主键，根据主键建立一颗高度平衡的B+树，B+树通常只有2～4层，根节点存放主键索引，叶子结点存放行记录的值；
## mysql是如何取出数据？
### 先说结论，mysql根据B+树索引，并不能找到相关的行，只能找到相关的页，将页加载到内存后，根据 Page_Directory提供的槽，使用二分查找法，根据槽中的主键key，找到行记录value--地址偏移，从而找到相关行记录。
## 什么时候添加B+树索引？
### 一般经验上，在访问表中，该字段可取值范围很大时才具备选择性，举个反例，sex字段（假设表中男女比例1:1），可取值范围一般只有'M', 'F'，这是添加B+树索引完全没有必要；相反，一个字段几乎不重复，并具备高选择性，例如姓名字段，则有必要添加B+树索引。此外，建立表中某列的索引，需先通过Cardinality查看其是否具备高选择性。
##MySQL查询索引失效的8种情况
##从sql编写规范以及sql编写方式两个角度上看
###1. 查询条件为多字段时，采用了or，导致全表扫描 （解决方法，为所需查询条件建立索引）
###2. 索引字段不独立，包含了表达式计算 select * from table where column = 1 + 1；（传入计算后的结果，select * from table where column = 2）
###3. 索引字段不独立，索引字段为函数参数 select * from table where substring(column, 1，3) = ‘Geo’; (传入计算结果)
###4. 使用了左模糊 select * from table where column like '%Geo%'; (去除左模糊，select * from table where column like 'Geo%')
###5. 不符合最左前缀查询 select * from table where lastName like 'Geo%'; (调整索引顺序，变成index（firstName， lastName）或者 index(firstName))
###6. SQL编写不规范 select * from table where column = c; (select * from table where column = 'c');
###7. 索引字段没有添加not null约束，而查询时使用了is null ；（添加非空约束）
###8.隐式转换导致索引失效，例如使用有些表使用int 有些使用bigint；
##综合上考虑，加索引需要考虑的维度
###从表数据量上看，如果数据量不多，没有必要加索引；
###从行记录操作情况上看，如果增删改的数量远远多于查询的数量，加索引对查询带来的性能提升没法对标常用业务增删改的负担，得不偿失；
###从横比字段上看，并不是所有where条件后的字段都需要加索引，如果在走了其中某个索引之后所筛选出的数据量已经很少的时候，再在其它字段上加索引带来的收益不明显且增加了增删改业务的负担，同上；
###从字段本身上看，如果字段本身可选择性比较少，例如只有 男 女这两个，那么加字段意义不大，挖出来的数据量并不能达到可预期的少量。