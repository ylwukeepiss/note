#  Spring之AOP
##  代理方式分为jdk动态代理跟cglib动态代理、静态代理
### jdk动态代理：代理对象必须是某个接口的实现，它是通过在运行期间创建一个接口的实现类来完成对目标对象的代理。
### cglib动态代理：实现原理与jdk动态代理类似，只是运行期间生成的代理对象是针对目标类扩展的子类。底层利用asm，直接操作字节码，性能比jdk动态代理强。
### 静态代理：在运行期间直接修改该类的字节码，因此调用时，已经是改变了的对象。
#### 碎碎念：bean的安全与否，一方面看bean的状态，一方面看spring的处理方式
#### 无状态的bean，spring容器默认会做成单例模式，达到线程安全🔐的目的
#### 有状态的bean，spring借助jvm内存分布情况，做成线程隔离（存放在ThreadLocal中，但要注意线程复用时，脏数据问题），或者是做成原型模式，每次都去new一个实例，达到线程安全的目的。

#### 静态代理 vs 动态代理（JDK动态代理和cglib动态代理）
<table>
    <th>代理类型</th>
    <th>代理对象</th>
    <th>依赖工具</th>
    <th>代理流程</th>
    <th>优点</th>
    <th>缺点</th>
    <tr>
        <td>静态代理</td>
        <td>手动实现接口，并调用</td>
        <td>-</td>
        <td>与POJO加载流程同步，执行时依赖手工指定流程</td>
        <td>可以做到不修改原对象的基础上进行扩展</td>
        <td>
            <li> 1. 违背开闭原则，只能通过手动完成代理操作，如果被代理对象增加新的方法，代理类需同步修改；
            <li> 2. 只能单一代理某个类，如果需要代理的类多时，会生成多个代理类；
        </td>
    </tr>
    <tr>
        <td>JDK动态代理</td>
        <td>接口</td>
        <td>基于JDK，利用反射机制</td>
        <td>
            <li> 1. 拿到被代理对象的引用，通过反射获取所有接口。
            <li> 2. 通过JDK Proxy类重新生成一个类，同时新的类要实现被代理接口的所有方法。
            <li> 3. 动态生成Java代码，把新加的业务逻辑方法由一定的逻辑代码调用。
            <li> 4. 编译生成新的Java代码.class。
            <li> 5. 将新生成的Class文件重新加载到JVM中运行。
        </td>
        <td>遵循开闭原则，期间只生成一个文件，生成效率高</td>
        <td>只能作用于实现了接口的类</td>
    </tr>
    <tr>
        <td>cglib动态代理</td>
        <td>接口、类</td>
        <td>利用开源包cglib</td>
        <td>
            <li> 1. 生成一个继承目标类的字节码文件；
            <li> 2. 基于FastClass，再生成一个Proxy字节码文件，和一个；
            <li> 3. 动态生成Java代码，把新加的业务逻辑方法由一定的逻辑代码调用。
            <li> 4. 编译生成新的Java代码.class。
        </td>
        <td>
            <li> 1. 遵循开闭原则；</li>
            <li> 2. 即可作用于接口，也可作用于类；</li>
            <li> 3. 调用时，执行效率高；</li>
        </td>
        <td>运行时生成3个文件，生成效率低</td>
    </tr>
</table>