#Java 锁
##synchronized原理
###synchronized是java提供的一种原子性同步锁，又叫做moniter锁，底层依赖操作系统的排它锁进行实现，目的是实现原子操作和解决共享变量内存可见性问题；jvm在编译时，遇到synchronize指令，会在代码块前后加上一条monitorenter 跟 monitorexit 字节码指令。

###synchronized本身维护了两个队列，entryList 跟 waitSet

###多线程访问synchronized同步代码块的时候，执行monitorenter指令的线程会去尝试获取锁，如果对象没有被锁定，或者已经获得了锁，锁的计数器就会+1，其它线程都会进入entryList等待进行锁的竞争，线程拿到锁的时候，cpu会将工作内存中的共享变量移除，从主内存中获取变量，处理完毕后，线程退出时，锁的计数器-1，当锁的计数器为0时，entryList中的其它线程继续抢夺锁

###释放锁的过程，cpu会将工作内存中的共享变量，写到主内存

###线程如果在运行的过程中调用了wait方法，将释放锁，并进入waitSet中，等待被notify或者noitfyAll唤醒，再获取到排它锁。

###当线程进入entryList，处于阻塞状态，或者，当线程进入waitSet，等待被唤醒时，系统都会从用户态切换到内核态，这是一项很大的开销。

##锁的优化机制
###锁的等级: 无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁，升级过程从左到右，从低到高，降级在一定条件下也有可能发生。

###自旋锁：由于大部分场景下，锁持有的时间很短，共享变量被锁住的时间也不长，因此，让线程自旋一段时间后去获取锁，好过线程被挂起，系统从用户态切换到内核态，开销巨大... 实现方式上，可以理解为通过一个空循环一段时间，目的是防止线程从用户态切换到内核态，通过参数-XX：Using Spining 去进行设定。

###锁消除：jvm在检测到一些同步代码块如果没有共享变量的竞争访问，就会将同步锁移除。

###锁粗化：有很多个操作都是对同一个对象加锁，那么jvm就会将这些同步操作合并成一个。

###偏向锁：

##ReentrantLock
###与synchronized相比，具备相同的互斥性和内存可见性，且性能相差不大，在同步代码块加锁和退出解锁时有相同的内存语义气，并且具有相同的可重入的加锁语义，区别在于，基于api实现的ReentrantLock能提供更多种类型的锁，定时锁，轮询锁，可中断锁，无条件锁，更灵活的加锁机制提供了更好的活跃性或性能。缺点是ReentrantLock必须在finally代码块中，执行unlock操作，而synchronized的加锁和释放锁由jvm去完成，由jvm操控的synchronized，具备更高的可调式性，毕竟jvm能清晰地记录哪个线程调用了synchronized锁

#volatile原理
##相比起synchronized的加锁方式解决共享变量的内存可见性问题，volatile是一种更轻量级的选择，它没有上下文切换开销，同时保证了使用volitale声明的变量，在修改时对其它线程可见，实现方式上时通过内存屏障禁止指令重排，协议是缓存一致性协议，会强迫对该变量的读取，从主内存进行读取。

##总结，锁的优化，离不开减少线程在抢锁时所消耗的资源，减少系统调用，减少上下文切换，减少变量在共享内存总线上的内存同步通信量。

###

##Happens-Before 8个规则
###传递性：操作a先于操作b执行，并且操作b先于操作a执行，那么a肯定先于b；
###线程启动：对于thread的start方法调用，先于线程内的所有动作；
###线程结束：线程内的所有操作，在类似于该线程join方法的成功返回之前执行完成，或者在isAlive方法返回false前执行完成；
###中断：
###监视器锁：解锁操作必须在同一个锁上的加锁操作之前执行；
###volatile变量：对volatile变量的写入操作先于对该变量的读操作，也就是说，在a线程的对volatile变量的写操作先于b线程对volatile变量的读操作，那么a线程的写结果对于b线程是可见的。
###程序顺序：如果程序的操作a在操作b之前执行，那么线程的操作a将在操作b之前执行；
###终结器规则：对象的构造函数必须在启动该对象的终结器之前执行完成；
